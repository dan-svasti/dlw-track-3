# -*- coding: utf-8 -*-
"""run_pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qwyTJ6rRXfYvdbJFWTGy627VTekDmr1C
"""

import argparse

def parse_args():
    parser = argparse.ArgumentParser(
        description="Offline crowd & loitering detection for rural CCTV"
    )
    parser.add_argument(
        "--video",
        type=str,
        required=True,
        help="Path to input MP4 video"
    )
    parser.add_argument(
        "--location",
        type=str,
        default="Camera 1",
        help="Location name for alerts"
    )
    return parser.parse_args()

  # use "python run_pipeline.py --video test_video.mp4" to run

import cv2
import pandas as pd
from ultralytics import YOLO

def load_video(video_path):
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        raise ValueError(f"Could not open video: {video_path}")
    fps = cap.get(cv2.CAP_PROP_FPS)
    return cap, fps

def load_model():
    return YOLO("yolov8n.pt")

def count_people(video_path, model):
    results = model.predict(
        source=video_path,
        conf=0.4,
        classes=[0],
        stream=True
    )

    counts = []
    for frame_idx, r in enumerate(results):
        num_people = len(r.boxes) if r.boxes is not None else 0
        counts.append({
            "frame": frame_idx,
            "people": num_people
        })

    return pd.DataFrame(counts)

def add_time_and_baseline(df, fps, k=3):
    df["time_sec"] = df["frame"] / fps

    median = df["people"].median()
    mad = (df["people"] - median).abs().median()

    df["is_crowd_anomaly"] = df["people"] > (median + k * mad)
    return df, median, mad

def detect_events(
    df,
    min_crowd_duration=10,
    loitering_people=2,
    loitering_duration=30
):
    df["is_loitering_candidate"] = df["people"] >= loitering_people
    df["is_suspicious"] = df["is_crowd_anomaly"] | df["is_loitering_candidate"]

    events = []
    current_event = None

    for _, row in df.iterrows():
        if row["is_suspicious"]:
            if current_event is None:
                current_event = {
                    "start_time": row["time_sec"],
                    "end_time": row["time_sec"],
                    "max_people": row["people"],
                    "type": "crowd" if row["is_crowd_anomaly"] else "loitering"
                }
            else:
                current_event["end_time"] = row["time_sec"]
                current_event["max_people"] = max(
                    current_event["max_people"], row["people"]
                )
        else:
            if current_event:
                duration = current_event["end_time"] - current_event["start_time"]
                if (
                    (current_event["type"] == "crowd" and duration >= min_crowd_duration)
                    or
                    (current_event["type"] == "loitering" and duration >= loitering_duration)
                ):
                    current_event["duration"] = duration
                    events.append(current_event)
                current_event = None

    return events

def save_evidence_frame(event, model, video_path, fps, output_dir="evidence"):
    import os
    os.makedirs(output_dir, exist_ok=True)

    cap = cv2.VideoCapture(video_path)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    mid_time = (event["start_time"] + event["end_time"]) / 2
    frame_idx = int(mid_time * fps)
    frame_idx = max(0, min(frame_idx, total_frames - 1))

    cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
    ret, frame = cap.read()
    if not ret:
        cap.release()
        return

    results = model.predict(frame, conf=0.4, classes=[0])
    annotated = results[0].plot()

    filename = f"{output_dir}/{event['type']}_{frame_idx}.jpg"
    cv2.imwrite(filename, annotated)
    cap.release()

def print_alert(event, location):
    print(
        f"\n ALERT: {event['type'].upper()} DETECTED\n"
        f"Location: {location}\n"
        f"Start: {event['start_time']:.1f}s\n"
        f"Duration: {event['duration']:.1f}s\n"
        f"Max people: {event['max_people']}\n"
        f"{'-'*40}"
    )

def main():
    args = parse_args()

    model = load_model()
    cap, fps = load_video(args.video)
    cap.release()

    df = count_people(args.video, model)
    df, median, mad = add_time_and_baseline(df, fps)

    events = detect_events(df)

    df.to_csv("people_counts.csv", index=False)
    pd.DataFrame(events).to_csv("alerts_log.csv", index=False)

    for event in events:
        print_alert(event, args.location)
        save_evidence_frame(event, model, args.video, fps)

if __name__ == "__main__":
    main()